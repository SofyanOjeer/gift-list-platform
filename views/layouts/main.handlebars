<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}} - GavaList</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
    {{> navigation}}
    
    <main class="container mt-4 animate-fade-in">
        {{{body}}}
    </main>

    <!-- Footer -->
    <footer class="bg-accent text-light mt-5 py-4">
        <div class="container text-center">
            <p class="mb-0">&copy; 2022 GavaList. Tous droits r√©serv√©s.</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/js/main.js"></script>
    
    <!-- Animation au scroll -->
    <script>
        // Animation au d√©filement
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = "1";
                    entry.target.style.transform = "translateY(0)";
                }
            });
        }, observerOptions);

        // Observer tous les √©l√©ments avec la classe .scroll-animate
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.card, .btn, .stats-item').forEach(el => {
                el.style.opacity = "0";
                el.style.transform = "translateY(20px)";
                el.style.transition = "opacity 0.6s ease, transform 0.6s ease";
                observer.observe(el);
            });
        });

        // Loading states pour les boutons
        document.addEventListener('submit', function(e) {
            const form = e.target;
            const submitBtn = form.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.classList.add('loading');
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Chargement...';
            }
        });


    </script>

<script>
// Gestion des notifications en temps r√©el - VERSION SANS D√âCALAGE
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOM charg√© - Initialisation notifications...');
    
    // FONCTION SANS D√âCALAGE MANUEL
    function formatNotificationDate(dateString) {
        if (!dateString) return 'Date inconnue';
        
        try {
            // Cr√©er la date en traitant explicitement le 'Z' (UTC)
            let date;
            if (dateString.endsWith('Z')) {
                // C'est une date UTC, la parser normalement
                date = new Date(dateString);
            } else {
                // C'est d√©j√† une date locale
                date = new Date(dateString);
            }
            
            if (isNaN(date.getTime())) return 'Date invalide';
            
            console.log('üîß Formatage date:', {
                originale: dateString,
                parsed: date.toString(),
                heures: date.getHours() + ':' + date.getMinutes()
            });
            
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            
            return `${day}/${month}/${year} √† ${hours}:${minutes}`;
        } catch (error) {
            console.error('Erreur formatage date:', error);
            return 'Date invalide';
        }
    }

    class NotificationManager {
    constructor() {
        this.updateInterval = 30000;
        this.touchStartX = 0;
        this.touchStartY = 0;
        this.init();
    }

    init() {
        console.log('üîî Initialisation NotificationManager avec support tactile');
        this.loadNotifications();
        this.setupEventListeners();
        this.setupTouchEvents(); // NOUVEAU : Gestes tactiles
        setInterval(() => this.loadNotifications(), this.updateInterval);
    }

     // NOUVEAU : Configuration des gestes tactiles
    setupTouchEvents() {
        const notificationDropdown = document.getElementById('notificationDropdown');
        const notificationsList = document.getElementById('notificationsList');
        
        if (notificationDropdown) {
            // Swipe down pour ouvrir les notifications
            notificationDropdown.addEventListener('touchstart', (e) => {
                this.touchStartY = e.touches[0].clientY;
            }, { passive: true });

            notificationDropdown.addEventListener('touchend', (e) => {
                const touchEndY = e.changedTouches[0].clientY;
                const diffY = touchEndY - this.touchStartY;
                
                // Swipe down de plus de 50px pour ouvrir
                if (diffY > 50) {
                    const dropdown = new bootstrap.Dropdown(notificationDropdown);
                    dropdown.show();
                }
            }, { passive: true });
        }


 if (notificationsList) {
            // Swipe gauche pour marquer comme lu
            notificationsList.addEventListener('touchstart', (e) => {
                if (e.target.closest('.notification-item')) {
                    this.touchStartX = e.touches[0].clientX;
                    this.touchStartY = e.touches[0].clientY;
                }
            }, { passive: true });

            notificationsList.addEventListener('touchmove', (e) => {
                if (!this.touchStartX) return;
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const diffX = this.touchStartX - touchX;
                const diffY = Math.abs(this.touchStartY - touchY);
                
                // Swipe horizontal avec peu de mouvement vertical
                if (diffX > 50 && diffY < 30) {
                    const notificationItem = e.target.closest('.notification-item');
                    if (notificationItem) {
                        notificationItem.style.transform = `translateX(-${diffX}px)`;
                        notificationItem.style.opacity = `${1 - (diffX / 100)}`;
                    }
                }
            }, { passive: true });

            notificationsList.addEventListener('touchend', (e) => {
                if (!this.touchStartX) return;
                
                const touchX = e.changedTouches[0].clientX;
                const diffX = this.touchStartX - touchX;
                
                if (diffX > 80) { // Swipe gauche suffisant
                    const notificationItem = e.target.closest('.notification-item');
                    if (notificationItem) {
                        const notificationId = notificationItem.dataset.notificationId;
                        this.markAsReadWithSwipe(notificationId, notificationItem);
                    }
                } else {
                    // Reset l'animation
                    const notificationItem = e.target.closest('.notification-item');
                    if (notificationItem) {
                        notificationItem.style.transform = '';
                        notificationItem.style.opacity = '';
                    }
                }
                
                this.touchStartX = 0;
                this.touchStartY = 0;
            }, { passive: true });
        }
    }

    // NOUVEAU : Animation de swipe
    async markAsReadWithSwipe(notificationId, element) {
        try {
            // Animation de disparition
            element.style.transition = 'all 0.3s ease';
            element.style.transform = 'translateX(-100%)';
            element.style.opacity = '0';
            
            setTimeout(async () => {
                await this.markAsRead(notificationId);
                this.loadNotifications(); // Recharger la liste
            }, 300);
            
        } catch (error) {
            console.error('Erreur swipe:', error);
        }
    }
        async loadNotifications() {
            try {
                console.log('üì° Chargement notifications...');
                const response = await fetch('/api/notifications');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Donn√©es re√ßues:', data);
                
                if (data.success) {
                    this.updateNotificationBadge(data.unreadCount);
                    this.updateNotificationList(data.notifications);
                } else {
                    console.error('‚ùå Erreur API:', data.error);
                }
            } catch (error) {
                console.error('üí• Erreur chargement notifications:', error);
            }
        }

        updateNotificationBadge(count) {
            const badge = document.getElementById('notificationCount');
            if (badge) {
                console.log('üîÑ Mise √† jour badge:', count);
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count;
                    badge.style.display = 'block';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        updateNotificationList(notifications) {
            const container = document.getElementById('notificationsList');
            if (!container) return;

            if (notifications.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4 text-muted">
                        <i class="fas fa-bell-slash fa-2x mb-2"></i>
                        <p class="mb-0">Aucune notification</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = notifications.map(notif => {
                // UTILISATION DE LA FONCTION CORRIG√âE
                const formattedDateTime = formatNotificationDate(notif.created_at);

                return `
                    <div class="notification-item p-3 border-bottom ${notif.is_read ? '' : 'bg-light'}" 
                         data-notification-id="${notif.id}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <h6 class="mb-1 small fw-bold">${notif.title}</h6>
                                <p class="mb-1 small">${notif.message}</p>
                                <small class="text-muted">
                                    <i class="fas fa-clock me-1"></i>
                                    ${formattedDateTime}
                                </small>
                            </div>
                            ${notif.is_read ? '' : '<span class="badge bg-primary ms-2">Nouveau</span>'}
                        </div>
                    </div>
                `;
            }).join('');

            this.attachNotificationEvents();
        }

        attachNotificationEvents() {
            const items = document.querySelectorAll('#notificationsList .notification-item');
            console.log('üîó Attachement √©v√©nements √†', items.length, 'notifications');
            
            items.forEach(item => {
                item.addEventListener('click', async (e) => {
                    const notificationId = item.dataset.notificationId;
                    console.log('üëÜ Clic notification:', notificationId);
                    
                    await this.markAsRead(notificationId);
                    
                    item.classList.remove('bg-light');
                    const badge = item.querySelector('.badge');
                    if (badge) badge.remove();
                    
                    this.loadNotifications();
                });
            });
        }

        setupEventListeners() {
            const markAllReadBtn = document.getElementById('markAllRead');
            if (markAllReadBtn) {
                console.log('üîó Bouton "Tout marquer comme lu" trouv√©');
                markAllReadBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    console.log('üëÜ Clic "Tout marquer comme lu"');
                    await this.markAllAsRead();
                });
            } else {
                console.log('‚ùå Bouton "Tout marquer comme lu" NON trouv√©');
            }
        }



        async markAllAsRead() {
            try {
                console.log('üì§ Marquer toutes comme lues...');
                const response = await fetch('/api/notifications/read-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                console.log('‚úÖ R√©ponse marquer toutes:', result);
                
                if (result.success) {
                    this.loadNotifications();
                }
            } catch (error) {
                console.error('üí• Erreur:', error);
            }
        }

        async markAsRead(notificationId) {
            try {
                console.log('üì§ Marquer comme lue:', notificationId);
                await fetch(`/api/notifications/${notificationId}/read`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
            } catch (error) {
                console.error('üí• Erreur:', error);
            }
        }
    }

// Initialisation
    if (document.getElementById('notificationDropdown')) {
        new NotificationManager();
    }
});


// Navigation par swipe entre les pages
class SwipeNavigation {
    constructor() {
        this.touchStartX = 0;
        this.minSwipeDistance = 80;
        this.init();
    }

    init() {
        if ('ontouchstart' in window) {
            document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
        }
    }

    handleTouchStart(e) {
        this.touchStartX = e.touches[0].clientX;
    }

    handleTouchEnd(e) {
        if (!this.touchStartX) return;

        const touchEndX = e.changedTouches[0].clientX;
        const diffX = this.touchStartX - touchEndX;

        if (Math.abs(diffX) > this.minSwipeDistance) {
            if (diffX > 0) {
                // Swipe gauche - aller √† la page suivante
                this.goForward();
            } else {
                // Swipe droite - retour
                this.goBack();
            }
        }

        this.touchStartX = 0;
    }

    goBack() {
        // Retour √† la page pr√©c√©dente ou fermeture de modal
        const openModal = document.querySelector('.modal.show');
        if (openModal) {
            const modal = bootstrap.Modal.getInstance(openModal);
            if (modal) modal.hide();
        } else if (history.length > 1) {
            history.back();
        }
    }

    goForward() {
        // Navigation vers l'avant (peut √™tre personnalis√©e)
        console.log('Swipe forward - navigation personnalisable');
    }
}

// Initialisation
document.addEventListener('DOMContentLoaded', function() {
    if ('ontouchstart' in window) {
        new SwipeNavigation();
    }
});
</script>

<style>
.notification-item {
  cursor: pointer;
  transition: background-color 0.2s;
}

.notification-item:hover {
  background-color: #f8f9fa !important;
}

.dropdown-menu {
  min-width: 350px;
}

.notification-list {
  max-height: 400px;
  overflow-y: auto;
}
</style>
</body>
</html>